<!DOCTYPE html>

<html>
<head>
  <title>A conversational introduction to rom-rb: part 2</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="index.html">
                index.rb
              </a>
            
              
              <a class="source" href="intro.html">
                intro.rb
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">#!/usr/bin/env ruby</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="a-conversational-introduction-to-rom-rb-part-2">A conversational introduction to rom-rb: part 2</h1>
<p><a href="."><em>See all parts</em></a></p>
<p>In <a href="/part-1.html">part 1</a>, we took our first steps with rom-rb, setting up
our basic persistence API and some repositories, then creating and reading
back records in our database.</p>
<p>This time, we’ll return query results in domain-specific objects, fetch
records with associations, and also look at updating records.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">require</span> <span class="hljs-string">"bundler/setup"</span>
<span class="hljs-keyword">require</span> <span class="hljs-string">"rom-sql"</span>
<span class="hljs-keyword">require</span> <span class="hljs-string">"rom-repository"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>We’re pulling in one new dependency this time: dry-types. dry-types works
very well alongside rom-rb, and will allow us to build type-safe domain
entites from our database records.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">require</span> <span class="hljs-string">"dry-types"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="define-our-app-s-persistence-api">Define our app’s persistence API</h2>
<p>In part 1, we started with a simple articles relation and corresponding
database table. Now we’ll expand things a little: we want our articles to
have many categories, so we’ll add a categories relation and an
articles_categories relation to join the two.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Relations</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Articles</span> &lt; ROM::Relation[:<span class="hljs-title">sql</span>]</span>
    schema(<span class="hljs-symbol">:articles</span>) <span class="hljs-keyword">do</span>
      attribute <span class="hljs-symbol">:id</span>, Types::Serial
      attribute <span class="hljs-symbol">:title</span>, Types::String
      attribute <span class="hljs-symbol">:published</span>, Types::Bool</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We’ll be using rom-rb’s new <code>associate</code> API to make building these
associations easy for us. Along with the <code>schema</code> API, this is new in
rom-rb’s master branches and will be released later in June.</p>
<p>Basic usage of the <code>associate</code> API is wonderfully simple. All we need
to do is declare the associations for this schema, and rom-rb will do
the work to connect things for us.</p>
<p>In this case, articles will have many categories through our
articles_categories join table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      associate <span class="hljs-keyword">do</span>
        many <span class="hljs-symbol">:categories</span>, <span class="hljs-symbol">through:</span> <span class="hljs-symbol">:articles_categories</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">by_id</span><span class="hljs-params">(id)</span></span>
      where(<span class="hljs-symbol">id:</span> id)
    <span class="hljs-keyword">end</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">published</span></span>
      where(<span class="hljs-symbol">published:</span> <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Our new Categories relation is straightforward: just an ID and a name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Categories</span> &lt; ROM::Relation[:<span class="hljs-title">sql</span>]</span>
    schema(<span class="hljs-symbol">:categories</span>) <span class="hljs-keyword">do</span>
      attribute <span class="hljs-symbol">:id</span>, Types::Serial
      attribute <span class="hljs-symbol">:name</span>, Types::String
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Now let’s join records from these tables together.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticlesCategories</span> &lt; ROM::Relation[:<span class="hljs-title">sql</span>]</span>
    schema(<span class="hljs-symbol">:articles_categories</span>) <span class="hljs-keyword">do</span>
      attribute <span class="hljs-symbol">:id</span>, Types::Serial</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The schema definition here has a couple of interesting things: these
<code>ForeignKey</code> types. This is simply a way to leave some extra metadata
on the type annotations so rom-rb can know to use these foreign key
columns when it builds its associations.</p>
<p>By default, rom-rb <code>ForeignKey</code> types are integers, but we can also
provide specific types like this:</p>
<pre><code class="lang-ruby">Types::ForeignKey(<span class="hljs-symbol">:articles</span>, <span class="hljs-symbol">type:</span> Types::String)
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>      attribute <span class="hljs-symbol">:article_id</span>, Types::ForeignKey(<span class="hljs-symbol">:articles</span>)
      attribute <span class="hljs-symbol">:category_id</span>, Types::ForeignKey(<span class="hljs-symbol">:categories</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>And here we put these foreign keys to work by specifying the
associations for this join table: each record belongs to both an
article and a category.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      associate <span class="hljs-keyword">do</span>
        belongs <span class="hljs-symbol">:articles</span>
        belongs <span class="hljs-symbol">:categories</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h2 id="define-our-app-s-types">Define our app’s types</h2>
<p>Type safety and shareable type definitions are an important pillar of any
<a href="http://dry-rb.org/">dry-rb</a> app, and here we can get a little taste of it. We’ll set up
entity classes to model the results coming out of our databases. Using <a href="http://dry-rb.org/gems/dry-types">dry-
types</a> structs here gives us a <a href="http://icelab.com.au/articles/inactive-records-the-value-objects-your-app-deserves/">number of benefits</a>,
including:</p>
<ul>
<li>Giving us a place to decorate the raw results from the database and
provide any special behaviour important for our app.</li>
<li>Making it easy for us to consume these objects in various contexts, since
we can be 100% confident in the type of data they contain - a dry-types
struct cannot be initialized with invalid attributes.</li>
</ul>
<p>We can also feel free to pass these objects all around our app, since by
convention we don’t mutate them, and unlike objects coming from the active
record pattern, there’s no way to trigger far-reaching side effects, like
datbase changes. These are also explicitly handled for us by rom-rb’s
dedicated query and commands objects, which we would never us accidentally.</p>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>The first thing we need to do with dry-types is to give our app a <code>Types</code>
module to include all of dry-type’s out-of-the-box definitions, all the
basic Ruby types like strings, integers, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Types</span></span>
  <span class="hljs-keyword">include</span> Dry::Types.<span class="hljs-keyword">module</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Now we can refer to this types module when we set up our struct subclasses.
Our Category struct has attributes to contain each of the values we expect
to get from rows in its corresponding database table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Category</span> &lt; Dry::Types::<span class="hljs-title">Struct</span></span>
  attribute <span class="hljs-symbol">:id</span>, Types::Strict::Int
  attribute <span class="hljs-symbol">:name</span>, Types::Strict::String
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>And Article is much the same, with one exception: we’re going to fetch each
article along with all of its associated categories, so we set up a
categories attribute, which is an array of Category objects. Here we see how
we can actually <em>build</em> upon our existing struct classes to provide quite
expressive, fully-featured type definitions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> &lt; Dry::Types::<span class="hljs-title">Struct</span></span>
  attribute <span class="hljs-symbol">:id</span>, Types::Strict::Int
  attribute <span class="hljs-symbol">:title</span>, Types::Strict::String
  attribute <span class="hljs-symbol">:published</span>, Types::Strict::Bool

  attribute <span class="hljs-symbol">:categories</span>, Types::Strict::Array.member(Category)
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2 id="define-our-app-s-repositories">Define our app’s repositories</h2>
<p>With these types in place, we can revisit our repositories. One thing to
note here is that, within this script, these repositories have now moved a
little <em>further away</em> from the relations that they use. This is actually a
fairer representation of how they should sit within a larger app:
repositories are not part of the basic persistence layer, but are rather a
way for your app to <em>hide away</em> the nitty-gritty details of persistence. In
this way, they’re part of your app’s collection of core objects.</p>
<p>We’ll take this a step further today by configuring these repositories to
return results wrapped up in the domain entities we defined just above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Repositories</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>While we’ve added 3 extra relations above, we’ll still be keeping only one
repository, which is another reflection of the different roles these two
things serve. Repositories are the sole interfaces through which our apps
work with persisted data, and in the case of this playground, all we need
to get are articles.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Articles</span> &lt; ROM::Repository[:<span class="hljs-title">articles</span>]</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>This repository can already access its root articles relation. Now we
need to make the categories relation accessible to it, so it can take
care of the association of articles to categories.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    relations <span class="hljs-symbol">:categories</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>We’re also adding one new command to the repository: <code>update</code>, combining
it with a <code>by_id</code> <em>restriction</em>. <code>by_id</code> is the query method we defined
in the articles relation, and it means here that the update command will
require an article ID to be provided, to ensure we only update a single
record and not every article in our database!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    commands <span class="hljs-symbol">:create</span>, <span class="hljs-symbol">update:</span> <span class="hljs-symbol">:by_id</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>We’re making 2 important changes to both of our repo’s query methods:</p>
<p>Firstly, we’re adding <code>aggregate(:categories)</code>, which will combine each
article result with all of its categories, using the associations we
declared back up in the relations.</p>
<p>Then we’re adding <code>.as(Article)</code>, which will see the data from each of
the results being passed to the constructor of our <code>Article</code> class.
Because this class is already configured to expect an array of
categories attributes, it will receive all the information it needs to
be initialized with valid data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">[]</span><span class="hljs-params">(id)</span></span>
      aggregate(<span class="hljs-symbol">:categories</span>)
        .by_id(id)
        .as(Article)
        .one!
    <span class="hljs-keyword">end</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">published</span></span>
      aggregate(<span class="hljs-symbol">:categories</span>)
        .published
        .as(Article)
        .to_a
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2 id="initialize-rom-rb">Initialize rom-rb</h2>
<p>We’re registering our two extra relations here. Again, this is something
that would be taken care of for us when using rom-rb in a larger app, but
it’s nice that rom-rb gives us all the setup hooks we need to make a little
playground script like this work too.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>config = ROM::Configuration.new(<span class="hljs-symbol">:sql</span>, <span class="hljs-string">"sqlite::memory"</span>)
config.register_relation Relations::Articles
config.register_relation Relations::Categories
config.register_relation Relations::ArticlesCategories
container = ROM.container(config)</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h2 id="prepare-our-database">Prepare our database</h2>
<p>We’re adding the migrations for our two extra tables here, and using the
<code>foreign_key</code> support from <a href="http://sequel.jeremyevans.net/rdoc/files/doc/schema_modification_rdoc.html#label-foreign_key">Sequel’s migration API</a> for proper database
integrity.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>container.gateways[<span class="hljs-symbol">:default</span>].tap <span class="hljs-keyword">do</span> <span class="hljs-params">|gateway|</span>
  migration = gateway.migration <span class="hljs-keyword">do</span>
    change <span class="hljs-keyword">do</span>
      create_table <span class="hljs-symbol">:articles</span> <span class="hljs-keyword">do</span>
        primary_key <span class="hljs-symbol">:id</span>
        string <span class="hljs-symbol">:title</span>, <span class="hljs-symbol">null:</span> <span class="hljs-literal">false</span>
        boolean <span class="hljs-symbol">:published</span>, <span class="hljs-symbol">null:</span> <span class="hljs-literal">false</span>, <span class="hljs-symbol">default:</span> <span class="hljs-literal">false</span>
      <span class="hljs-keyword">end</span>

      create_table <span class="hljs-symbol">:categories</span> <span class="hljs-keyword">do</span>
        primary_key <span class="hljs-symbol">:id</span>
        string <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">null:</span> <span class="hljs-literal">false</span>
      <span class="hljs-keyword">end</span>

      create_table <span class="hljs-symbol">:articles_categories</span> <span class="hljs-keyword">do</span>
        primary_key <span class="hljs-symbol">:id</span>
        foreign_key <span class="hljs-symbol">:article_id</span>, <span class="hljs-symbol">:articles</span>, <span class="hljs-symbol">null:</span> <span class="hljs-literal">false</span>
        foreign_key <span class="hljs-symbol">:category_id</span>, <span class="hljs-symbol">:categories</span>, <span class="hljs-symbol">null:</span> <span class="hljs-literal">false</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
  migration.apply gateway.connection, <span class="hljs-symbol">:up</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h2 id="let-s-play-">Let’s play!</h2>
<p>Alright, everything’s in place. Let’s try out these changes!</p>

            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>First, get a repo to use.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>repo = Repositories::Articles.new(container)</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Let’s just manually seed our database with some data. We need to make some
articles, categories and their associations via the join table. Next week
we’ll look at how we can do this nicely with rom-rb, but for now  we need to
sneak in a couple of lines of SQL.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>repo.create(<span class="hljs-symbol">title:</span> <span class="hljs-string">"Hello rom-rb"</span>, <span class="hljs-symbol">published:</span> <span class="hljs-literal">true</span>)

connection = container.gateways[<span class="hljs-symbol">:default</span>].connection
connection.execute <span class="hljs-string">"INSERT INTO categories (name) VALUES ('dry-rb')"</span>
connection.execute <span class="hljs-string">"INSERT INTO categories (name) VALUES ('rom-rb')"</span>
connection.execute <span class="hljs-string">"INSERT INTO articles_categories (article_id, category_id) VALUES (1, 1)"</span>
connection.execute <span class="hljs-string">"INSERT INTO articles_categories (article_id, category_id) VALUES (1, 2)"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Now we should be able to see some results.</p>
<p>And look! Here we are: our article, wrapped up in a proper domain object,
including both of its associated categories:</p>
<pre><code class="lang-ruby">repo.published
<span class="hljs-comment"># =&gt; [#&lt;Article id=1 title="Hello rom-rb" published=true categories=[#&lt;Category id=1 name="dry-rb"&gt;, #&lt;Category id=2 name="rom-rb"&gt;]&gt;]</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>puts <span class="hljs-string">"Published articles?"</span>
published_articles = repo.published
puts published_articles.inspect</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>And with our repo’s new <code>update</code> command, we should be able to modify that
article.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>repo.update(published_articles.first.id, <span class="hljs-symbol">title:</span> <span class="hljs-string">"rom-rb and dry-rb, sitting in a tree"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Has it worked? Yes!</p>
<pre><code class="lang-ruby">repo.published.first.title
<span class="hljs-comment"># =&gt; "rom-rb and dry-rb, sitting in a tree"</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>puts <span class="hljs-string">"Updated title?"</span>
puts repo.published.first.title.inspect</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h2 id="next-steps">Next steps</h2>
<p>We’ve seen a few more features of the upcoming rom-rb release, but our
journey isn’t complete. We’ll come back for one more part, in which we’ll
look at a command graph to create both articles and categories at the same
time.</p>
<p>Until then, if you can <a href="https://github.com/icelab/conversational-intro-to-rom-rb">clone this playground from GitHub</a> and
experiment:</p>
<pre><code>git clone https://github.com/icelab/conversational-intro-to-rom-rb
cd conversational-intro-to-rom-rb
bundle
./intro.rb
</code></pre><p>Feel free to extend the playground, make your own changes and see how things
work!</p>
<p>And if you want to learn more, check out the <a href="http://rom-rb.org/learn/">helpful documentation</a>
on the rom-rb website, and join the <a href="https://gitter.im/rom-rb/chat">gitter chat</a> if you have any
questions!</p>

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
